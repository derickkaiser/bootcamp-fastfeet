{"ast":null,"code":"var _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _reactNative = require(\"react-native\");\n\nvar _reactNavigation = require(\"react-navigation\");\n\nvar _reactNativeScreens = require(\"react-native-screens\");\n\nvar _reactNativeGestureHandler = require(\"react-native-gesture-handler\");\n\nvar _StackViewCard = _interopRequireDefault(require(\"./StackViewCard\"));\n\nvar _Header = _interopRequireDefault(require(\"../Header/Header\"));\n\nvar _StackViewTransitionConfigs = _interopRequireDefault(require(\"./StackViewTransitionConfigs\"));\n\nvar _HeaderStyleInterpolator = _interopRequireDefault(require(\"../Header/HeaderStyleInterpolator\"));\n\nvar _StackGestureContext = _interopRequireDefault(require(\"../../utils/StackGestureContext\"));\n\nvar _clamp = _interopRequireDefault(require(\"../../utils/clamp\"));\n\nvar _ReactNativeFeatures = require(\"../../utils/ReactNativeFeatures\");\n\nvar _jsxFileName = \"/Users/satya/Workspace/Callstack/react-navigation-stack/src/views/StackView/StackViewLayout.tsx\";\nvar IPHONE_XS_HEIGHT = 812;\nvar IPHONE_XR_HEIGHT = 896;\n\nvar _Dimensions$get = _reactNative.Dimensions.get('window'),\n    WINDOW_WIDTH = _Dimensions$get.width,\n    WINDOW_HEIGHT = _Dimensions$get.height;\n\nvar IS_IPHONE_X = _reactNative.Platform.OS === 'ios' && !_reactNative.Platform.isPad && !_reactNative.Platform.isTVOS && (WINDOW_HEIGHT === IPHONE_XS_HEIGHT || WINDOW_WIDTH === IPHONE_XS_HEIGHT || WINDOW_HEIGHT === IPHONE_XR_HEIGHT || WINDOW_WIDTH === IPHONE_XR_HEIGHT);\n\nvar EaseInOut = _reactNative.Easing.inOut(_reactNative.Easing.ease);\n\nvar HEADER_LAYOUT_PRESET = ['center', 'left'];\nvar HEADER_TRANSITION_PRESET = ['fade-in-place', 'uikit'];\nvar HEADER_BACKGROUND_TRANSITION_PRESET = ['toggle', 'fade', 'translate'];\nvar ANIMATION_DURATION = 500;\nvar POSITION_THRESHOLD = 1 / 2;\nvar GESTURE_RESPONSE_DISTANCE_HORIZONTAL = 50;\nvar GESTURE_RESPONSE_DISTANCE_VERTICAL = 135;\nvar USE_NATIVE_DRIVER = _reactNative.Platform.OS === 'android' || _reactNative.Platform.OS === 'ios';\n\nvar getDefaultHeaderHeight = function getDefaultHeaderHeight(isLandscape) {\n  if (_reactNative.Platform.OS === 'ios') {\n    if (isLandscape && !_reactNative.Platform.isPad) {\n      return 32;\n    } else if (IS_IPHONE_X) {\n      return 88;\n    } else {\n      return 64;\n    }\n  } else if (_reactNative.Platform.OS === 'android') {\n    return 56;\n  } else {\n    return 64;\n  }\n};\n\nvar StackViewLayout = function (_React$Component) {\n  (0, _inherits2.default)(StackViewLayout, _React$Component);\n\n  function StackViewLayout(props) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, StackViewLayout);\n    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(StackViewLayout).call(this, props));\n    _this.immediateIndex = null;\n\n    _this.handleFloatingHeaderLayout = function (e) {\n      var height = e.nativeEvent.layout.height;\n\n      if (height !== _this.state.floatingHeaderHeight) {\n        _this.setState({\n          floatingHeaderHeight: height\n        });\n      }\n    };\n\n    _this.handlePanGestureStateChange = function (_ref) {\n      var nativeEvent = _ref.nativeEvent;\n\n      if (nativeEvent.oldState === _reactNativeGestureHandler.State.ACTIVE) {\n        if (_this.positionSwitch.__getValue() === 1) {\n          return;\n        }\n\n        if (_this.isMotionVertical()) {\n          _this.handleReleaseVertical(nativeEvent);\n        } else {\n          _this.handleReleaseHorizontal(nativeEvent);\n        }\n      } else if (nativeEvent.state === _reactNativeGestureHandler.State.ACTIVE) {\n        _this.props.onGestureBegin && _this.props.onGestureBegin();\n\n        _this.positionSwitch.setValue(0);\n      }\n    };\n\n    _this.renderCard = function (scene) {\n      var _this$props = _this.props,\n          transitionProps = _this$props.transitionProps,\n          cardShadowEnabled = _this$props.cardShadowEnabled,\n          cardOverlayEnabled = _this$props.cardOverlayEnabled,\n          transparentCard = _this$props.transparentCard,\n          cardStyle = _this$props.cardStyle;\n      var _ref2 = _this.transitionConfig,\n          screenInterpolator = _ref2.screenInterpolator;\n      var style = screenInterpolator && screenInterpolator((0, _objectSpread2.default)({}, transitionProps, {\n        shadowEnabled: cardShadowEnabled,\n        cardOverlayEnabled: cardOverlayEnabled,\n        position: _this.position,\n        scene: scene\n      }));\n      var options = scene.descriptor.options;\n      var hasHeader = options.header !== null && options.headerShown !== false;\n\n      var headerMode = _this.getHeaderMode();\n\n      var floatingContainerStyle = _reactNative.StyleSheet.absoluteFill;\n\n      if (hasHeader && headerMode === 'float' && !options.headerTransparent) {\n        floatingContainerStyle = (0, _objectSpread2.default)({}, _reactNative.Platform.select({\n          web: {},\n          default: _reactNative.StyleSheet.absoluteFillObject\n        }), {\n          paddingTop: _this.state.floatingHeaderHeight\n        });\n      }\n\n      return React.createElement(_StackViewCard.default, (0, _extends2.default)({}, transitionProps, {\n        key: \"card_\" + scene.key,\n        position: _this.position,\n        realPosition: transitionProps.position,\n        animatedStyle: style,\n        transparent: transparentCard,\n        style: [floatingContainerStyle, cardStyle],\n        scene: scene,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 975\n        }\n      }), _this.renderInnerScene(scene));\n    };\n\n    _this.panGestureRef = React.createRef();\n    _this.gestureX = new _reactNative.Animated.Value(0);\n    _this.gestureY = new _reactNative.Animated.Value(0);\n    _this.positionSwitch = new _reactNative.Animated.Value(1);\n\n    if (_reactNative.Animated.subtract) {\n      _this.gestureSwitch = _reactNative.Animated.subtract(1, _this.positionSwitch);\n    } else {\n      _this.gestureSwitch = _reactNative.Animated.add(1, _reactNative.Animated.multiply(-1, _this.positionSwitch));\n    }\n\n    _this.gestureEvent = _reactNative.Animated.event([{\n      nativeEvent: {\n        translationX: _this.gestureX,\n        translationY: _this.gestureY\n      }\n    }], {\n      useNativeDriver: USE_NATIVE_DRIVER\n    });\n    _this.state = {\n      floatingHeaderHeight: getDefaultHeaderHeight(props.isLandscape)\n    };\n    return _this;\n  }\n\n  (0, _createClass2.default)(StackViewLayout, [{\n    key: \"renderHeader\",\n    value: function renderHeader(scene, headerMode) {\n      var options = scene.descriptor.options;\n      var header = options.header,\n          headerShown = options.headerShown;\n\n      if (__DEV__ && typeof header === 'string') {\n        throw new Error(\"Invalid header value: \\\"\" + header + \"\\\". The header option must be a valid React component or null, not a string.\");\n      }\n\n      if ((header === null || headerShown === false) && headerMode === 'screen') {\n        return null;\n      }\n\n      if (React.isValidElement(header)) {\n        return header;\n      }\n\n      var renderHeader = header || function (props) {\n        return React.createElement(_Header.default, (0, _extends2.default)({}, props, {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 217\n          }\n        }));\n      };\n\n      var _ref3 = this.transitionConfig,\n          headerLeftInterpolator = _ref3.headerLeftInterpolator,\n          headerTitleInterpolator = _ref3.headerTitleInterpolator,\n          headerRightInterpolator = _ref3.headerRightInterpolator,\n          headerBackgroundInterpolator = _ref3.headerBackgroundInterpolator;\n      var backgroundTransitionPresetInterpolator = this.getHeaderBackgroundTransitionPreset();\n\n      if (backgroundTransitionPresetInterpolator) {\n        headerBackgroundInterpolator = backgroundTransitionPresetInterpolator;\n      }\n\n      var _this$props2 = this.props,\n          transitionProps = _this$props2.transitionProps,\n          passProps = (0, _objectWithoutProperties2.default)(_this$props2, [\"transitionProps\"]);\n      return React.createElement(_reactNavigation.NavigationProvider, {\n        value: scene.descriptor.navigation,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 234\n        }\n      }, renderHeader((0, _objectSpread2.default)({}, passProps, transitionProps, {\n        position: this.position,\n        scene: scene,\n        mode: headerMode,\n        transitionPreset: this.getHeaderTransitionPreset(),\n        layoutPreset: this.getHeaderLayoutPreset(),\n        backTitleVisible: this.getHeaderBackTitleVisible(),\n        leftInterpolator: headerLeftInterpolator,\n        titleInterpolator: headerTitleInterpolator,\n        rightInterpolator: headerRightInterpolator,\n        backgroundInterpolator: headerBackgroundInterpolator\n      })));\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(resetToIndex, duration) {\n      if (_reactNative.Platform.OS === 'ios' && (0, _ReactNativeFeatures.supportsImprovedSpringAnimation)()) {\n        _reactNative.Animated.spring(this.props.transitionProps.position, {\n          toValue: resetToIndex,\n          stiffness: 6000,\n          damping: 100,\n          mass: 3,\n          overshootClamping: true,\n          restDisplacementThreshold: 0.01,\n          restSpeedThreshold: 0.01,\n          useNativeDriver: USE_NATIVE_DRIVER\n        }).start();\n      } else {\n        _reactNative.Animated.timing(this.props.transitionProps.position, {\n          toValue: resetToIndex,\n          duration: duration,\n          easing: EaseInOut,\n          useNativeDriver: USE_NATIVE_DRIVER\n        }).start();\n      }\n    }\n  }, {\n    key: \"goBack\",\n    value: function goBack(backFromIndex, duration) {\n      var _this2 = this;\n\n      var _this$props$transitio = this.props.transitionProps,\n          navigation = _this$props$transitio.navigation,\n          position = _this$props$transitio.position,\n          scenes = _this$props$transitio.scenes;\n      var toValue = Math.max(backFromIndex - 1, 0);\n      this.immediateIndex = toValue;\n\n      var onCompleteAnimation = function onCompleteAnimation() {\n        _this2.immediateIndex = null;\n        var backFromScene = scenes.find(function (s) {\n          return s.index === toValue + 1;\n        });\n\n        if (backFromScene) {\n          navigation.dispatch(_reactNavigation.NavigationActions.back({\n            key: backFromScene.route.key,\n            immediate: true\n          }));\n          navigation.dispatch(_reactNavigation.StackActions.completeTransition());\n        }\n      };\n\n      if (_reactNative.Platform.OS === 'ios' && (0, _ReactNativeFeatures.supportsImprovedSpringAnimation)()) {\n        _reactNative.Animated.spring(position, {\n          toValue: toValue,\n          stiffness: 7000,\n          damping: 300,\n          mass: 3,\n          overshootClamping: true,\n          restDisplacementThreshold: 0.01,\n          restSpeedThreshold: 0.01,\n          useNativeDriver: USE_NATIVE_DRIVER\n        }).start(onCompleteAnimation);\n      } else {\n        _reactNative.Animated.timing(position, {\n          toValue: toValue,\n          duration: duration,\n          easing: EaseInOut,\n          useNativeDriver: USE_NATIVE_DRIVER\n        }).start(onCompleteAnimation);\n      }\n    }\n  }, {\n    key: \"prepareAnimated\",\n    value: function prepareAnimated() {\n      if (this.props === this.prevProps) {\n        return;\n      }\n\n      this.prevProps = this.props;\n      this.prepareGesture();\n      this.preparePosition();\n      this.prepareTransitionConfig();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.prepareAnimated();\n      var transitionProps = this.props.transitionProps;\n      var index = transitionProps.navigation.state.index,\n          scenes = transitionProps.scenes;\n      var headerMode = this.getHeaderMode();\n      var floatingHeader = null;\n\n      if (headerMode === 'float') {\n        var scene = transitionProps.scene;\n        floatingHeader = React.createElement(_reactNative.View, {\n          style: styles.floatingHeader,\n          pointerEvents: \"box-none\",\n          onLayout: this.handleFloatingHeaderLayout,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 356\n          }\n        }, this.renderHeader(scene, headerMode));\n      }\n\n      return React.createElement(_reactNativeGestureHandler.PanGestureHandler, (0, _extends2.default)({}, this.gestureActivationCriteria(), {\n        ref: this.panGestureRef,\n        onGestureEvent: this.gestureEvent,\n        onHandlerStateChange: this.handlePanGestureStateChange,\n        enabled: index > 0 && this.isGestureEnabled(),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 367\n        }\n      }), React.createElement(_reactNative.Animated.View, {\n        style: [styles.container, this.context === 'light' ? this.transitionConfig.containerStyleLight : this.transitionConfig.containerStyleDark, this.transitionConfig.containerStyle],\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 374\n        }\n      }, React.createElement(_StackGestureContext.default.Provider, {\n        value: this.panGestureRef,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 383\n        }\n      }, React.createElement(_reactNativeScreens.ScreenContainer, {\n        style: styles.scenes,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 384\n        }\n      }, scenes.map(this.renderCard)), floatingHeader)));\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var prevState = prevProps.transitionProps.navigation.state;\n      var state = this.props.transitionProps.navigation.state;\n\n      if (prevState.index !== state.index) {\n        this.maybeCancelGesture();\n      }\n    }\n  }, {\n    key: \"getGestureResponseDistance\",\n    value: function getGestureResponseDistance() {\n      var scene = this.props.transitionProps.scene;\n      var options = scene.descriptor.options;\n      var _options$gestureRespo = options.gestureResponseDistance,\n          userGestureResponseDistance = _options$gestureRespo === void 0 ? {} : _options$gestureRespo;\n      return this.isModal() ? userGestureResponseDistance.vertical || GESTURE_RESPONSE_DISTANCE_VERTICAL : userGestureResponseDistance.horizontal || GESTURE_RESPONSE_DISTANCE_HORIZONTAL;\n    }\n  }, {\n    key: \"gestureActivationCriteria\",\n    value: function gestureActivationCriteria() {\n      var layout = this.props.transitionProps.layout;\n      var gestureResponseDistance = this.getGestureResponseDistance();\n      var isMotionInverted = this.isMotionInverted();\n\n      if (this.isMotionVertical()) {\n        var height = layout.height.__getValue();\n\n        return {\n          maxDeltaX: 15,\n          minOffsetY: isMotionInverted ? -5 : 5,\n          hitSlop: isMotionInverted ? {\n            top: -height + gestureResponseDistance\n          } : {\n            bottom: -height + gestureResponseDistance\n          }\n        };\n      } else {\n        var width = layout.width.__getValue();\n\n        var hitSlop = -width + gestureResponseDistance;\n        return {\n          minOffsetX: isMotionInverted ? -5 : 5,\n          maxDeltaY: 20,\n          hitSlop: isMotionInverted ? {\n            left: hitSlop\n          } : {\n            right: hitSlop\n          }\n        };\n      }\n    }\n  }, {\n    key: \"isGestureEnabled\",\n    value: function isGestureEnabled() {\n      var gesturesEnabled = this.props.transitionProps.scene.descriptor.options.gesturesEnabled;\n      return typeof gesturesEnabled === 'boolean' ? gesturesEnabled : _reactNative.Platform.OS === 'ios';\n    }\n  }, {\n    key: \"isMotionVertical\",\n    value: function isMotionVertical() {\n      return this.isModal();\n    }\n  }, {\n    key: \"isModal\",\n    value: function isModal() {\n      return this.props.mode === 'modal';\n    }\n  }, {\n    key: \"isMotionInverted\",\n    value: function isMotionInverted() {\n      var scene = this.props.transitionProps.scene;\n      var options = scene.descriptor.options;\n      var gestureDirection = options.gestureDirection;\n\n      if (this.isModal()) {\n        return gestureDirection === 'inverted';\n      } else {\n        return typeof gestureDirection === 'string' ? gestureDirection === 'inverted' : _reactNative.I18nManager.isRTL;\n      }\n    }\n  }, {\n    key: \"computeHorizontalGestureValue\",\n    value: function computeHorizontalGestureValue(_ref4) {\n      var translationX = _ref4.translationX;\n      var _this$props$transitio2 = this.props.transitionProps,\n          navigation = _this$props$transitio2.navigation,\n          layout = _this$props$transitio2.layout;\n      var index = navigation.state.index;\n\n      var distance = layout.width.__getValue();\n\n      var x = this.isMotionInverted() ? -1 * translationX : translationX;\n      var value = index - x / distance;\n      return (0, _clamp.default)(index - 1, value, index);\n    }\n  }, {\n    key: \"computeVerticalGestureValue\",\n    value: function computeVerticalGestureValue(_ref5) {\n      var translationY = _ref5.translationY;\n      var _this$props$transitio3 = this.props.transitionProps,\n          navigation = _this$props$transitio3.navigation,\n          layout = _this$props$transitio3.layout;\n      var index = navigation.state.index;\n\n      var distance = layout.height.__getValue();\n\n      var y = this.isMotionInverted() ? -1 * translationY : translationY;\n      var value = index - y / distance;\n      return (0, _clamp.default)(index - 1, value, index);\n    }\n  }, {\n    key: \"maybeCancelGesture\",\n    value: function maybeCancelGesture() {\n      this.positionSwitch.setValue(1);\n    }\n  }, {\n    key: \"prepareGesture\",\n    value: function prepareGesture() {\n      if (!this.isGestureEnabled()) {\n        if (this.positionSwitch.__getValue() !== 1) {\n          this.positionSwitch.setValue(1);\n        }\n\n        this.gesturePosition = undefined;\n        return;\n      }\n\n      if (this.props.transitionProps.layout.width.__getValue() === 0 || this.props.transitionProps.layout.height.__getValue() === 0) {\n        return;\n      }\n\n      if (this.isMotionVertical()) {\n        this.prepareGestureVertical();\n      } else {\n        this.prepareGestureHorizontal();\n      }\n    }\n  }, {\n    key: \"prepareGestureHorizontal\",\n    value: function prepareGestureHorizontal() {\n      var index = this.props.transitionProps.navigation.state.index;\n\n      if (this.isMotionInverted()) {\n        this.gesturePosition = _reactNative.Animated.add(index, _reactNative.Animated.divide(this.gestureX, this.props.transitionProps.layout.width)).interpolate({\n          inputRange: [index - 1, index],\n          outputRange: [index - 1, index],\n          extrapolate: 'clamp'\n        });\n      } else {\n        this.gesturePosition = _reactNative.Animated.add(index, _reactNative.Animated.multiply(-1, _reactNative.Animated.divide(this.gestureX, this.props.transitionProps.layout.width))).interpolate({\n          inputRange: [index - 1, index],\n          outputRange: [index - 1, index],\n          extrapolate: 'clamp'\n        });\n      }\n    }\n  }, {\n    key: \"prepareGestureVertical\",\n    value: function prepareGestureVertical() {\n      var index = this.props.transitionProps.navigation.state.index;\n\n      if (this.isMotionInverted()) {\n        this.gesturePosition = _reactNative.Animated.add(index, _reactNative.Animated.divide(this.gestureY, this.props.transitionProps.layout.height)).interpolate({\n          inputRange: [index - 1, index],\n          outputRange: [index - 1, index],\n          extrapolate: 'clamp'\n        });\n      } else {\n        this.gesturePosition = _reactNative.Animated.add(index, _reactNative.Animated.multiply(-1, _reactNative.Animated.divide(this.gestureY, this.props.transitionProps.layout.height))).interpolate({\n          inputRange: [index - 1, index],\n          outputRange: [index - 1, index],\n          extrapolate: 'clamp'\n        });\n      }\n    }\n  }, {\n    key: \"handleReleaseHorizontal\",\n    value: function handleReleaseHorizontal(nativeEvent) {\n      var _this$props$transitio4 = this.props.transitionProps,\n          navigation = _this$props$transitio4.navigation,\n          position = _this$props$transitio4.position,\n          layout = _this$props$transitio4.layout;\n      var index = navigation.state.index;\n      var immediateIndex = this.immediateIndex == null ? index : this.immediateIndex;\n\n      var distance = layout.width.__getValue();\n\n      var movementDirection = this.isMotionInverted() ? -1 : 1;\n      var movedDistance = movementDirection * nativeEvent.translationX;\n      var gestureVelocity = movementDirection * nativeEvent.velocityX;\n      var defaultVelocity = distance / ANIMATION_DURATION;\n      var velocity = Math.max(Math.abs(gestureVelocity), defaultVelocity);\n      var resetDuration = this.isMotionInverted() ? (distance - movedDistance) / velocity : movedDistance / velocity;\n      var goBackDuration = this.isMotionInverted() ? movedDistance / velocity : (distance - movedDistance) / velocity;\n      var value = this.computeHorizontalGestureValue(nativeEvent);\n      position.setValue(value);\n      this.positionSwitch.setValue(1);\n\n      if (gestureVelocity < -50) {\n        this.props.onGestureCanceled && this.props.onGestureCanceled();\n        this.reset(immediateIndex, resetDuration);\n        return;\n      }\n\n      if (gestureVelocity > 50) {\n        this.props.onGestureEnd && this.props.onGestureEnd();\n        this.goBack(immediateIndex, goBackDuration);\n        return;\n      }\n\n      if (value <= index - POSITION_THRESHOLD) {\n        this.props.onGestureEnd && this.props.onGestureEnd();\n        this.goBack(immediateIndex, goBackDuration);\n      } else {\n        this.props.onGestureCanceled && this.props.onGestureCanceled();\n        this.reset(immediateIndex, resetDuration);\n      }\n    }\n  }, {\n    key: \"handleReleaseVertical\",\n    value: function handleReleaseVertical(nativeEvent) {\n      var _this$props$transitio5 = this.props.transitionProps,\n          navigation = _this$props$transitio5.navigation,\n          position = _this$props$transitio5.position,\n          layout = _this$props$transitio5.layout;\n      var index = navigation.state.index;\n      var immediateIndex = this.immediateIndex == null ? index : this.immediateIndex;\n\n      var distance = layout.height.__getValue();\n\n      var isMotionInverted = this.isMotionInverted();\n      var movementDirection = isMotionInverted ? -1 : 1;\n      var movedDistance = movementDirection * nativeEvent.translationY;\n      var gestureVelocity = movementDirection * nativeEvent.velocityY;\n      var defaultVelocity = distance / ANIMATION_DURATION;\n      var velocity = Math.max(Math.abs(gestureVelocity), defaultVelocity);\n      var resetDuration = isMotionInverted ? (distance - movedDistance) / velocity : movedDistance / velocity;\n      var goBackDuration = isMotionInverted ? movedDistance / velocity : (distance - movedDistance) / velocity;\n      var value = this.computeVerticalGestureValue(nativeEvent);\n      position.setValue(value);\n      this.positionSwitch.setValue(1);\n\n      if (gestureVelocity < -50) {\n        this.props.onGestureCanceled && this.props.onGestureCanceled();\n        this.reset(immediateIndex, resetDuration);\n        return;\n      }\n\n      if (gestureVelocity > 50) {\n        this.props.onGestureEnd && this.props.onGestureEnd();\n        this.goBack(immediateIndex, goBackDuration);\n        return;\n      }\n\n      if (value <= index - POSITION_THRESHOLD) {\n        this.props.onGestureEnd && this.props.onGestureEnd();\n        this.goBack(immediateIndex, goBackDuration);\n      } else {\n        this.props.onGestureCanceled && this.props.onGestureCanceled();\n        this.reset(immediateIndex, resetDuration);\n      }\n    }\n  }, {\n    key: \"getHeaderMode\",\n    value: function getHeaderMode() {\n      if (this.props.headerMode) {\n        return this.props.headerMode;\n      }\n\n      if (_reactNative.Platform.OS === 'android' || this.props.mode === 'modal') {\n        return 'screen';\n      }\n\n      return 'float';\n    }\n  }, {\n    key: \"getHeaderBackgroundTransitionPreset\",\n    value: function getHeaderBackgroundTransitionPreset() {\n      var headerBackgroundTransitionPreset = this.props.headerBackgroundTransitionPreset;\n\n      if (headerBackgroundTransitionPreset) {\n        if (HEADER_BACKGROUND_TRANSITION_PRESET.includes(headerBackgroundTransitionPreset)) {\n          if (headerBackgroundTransitionPreset === 'fade') {\n            return _HeaderStyleInterpolator.default.forBackgroundWithFade;\n          } else if (headerBackgroundTransitionPreset === 'translate') {\n            return _HeaderStyleInterpolator.default.forBackgroundWithTranslation;\n          } else if (headerBackgroundTransitionPreset === 'toggle') {\n            return _HeaderStyleInterpolator.default.forBackgroundWithInactiveHidden;\n          }\n        } else if (__DEV__) {\n          console.error(\"Invalid configuration applied for headerBackgroundTransitionPreset - expected one of \" + HEADER_BACKGROUND_TRANSITION_PRESET.join(', ') + \" but received \" + JSON.stringify(headerBackgroundTransitionPreset));\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getHeaderLayoutPreset\",\n    value: function getHeaderLayoutPreset() {\n      var headerLayoutPreset = this.props.headerLayoutPreset;\n\n      if (headerLayoutPreset) {\n        if (__DEV__) {\n          if (this.getHeaderTransitionPreset() === 'uikit' && headerLayoutPreset === 'left' && _reactNative.Platform.OS === 'ios') {\n            console.warn(\"headerTransitionPreset with the value 'uikit' is incompatible with headerLayoutPreset 'left'\");\n          }\n        }\n\n        if (HEADER_LAYOUT_PRESET.includes(headerLayoutPreset)) {\n          return headerLayoutPreset;\n        }\n\n        if (__DEV__) {\n          console.error(\"Invalid configuration applied for headerLayoutPreset - expected one of \" + HEADER_LAYOUT_PRESET.join(', ') + \" but received \" + JSON.stringify(headerLayoutPreset));\n        }\n      }\n\n      if (_reactNative.Platform.OS !== 'ios') {\n        return 'left';\n      } else {\n        return 'center';\n      }\n    }\n  }, {\n    key: \"getHeaderTransitionPreset\",\n    value: function getHeaderTransitionPreset() {\n      if (_reactNative.Platform.OS !== 'ios' || this.getHeaderMode() === 'screen') {\n        return 'fade-in-place';\n      }\n\n      var headerTransitionPreset = this.props.headerTransitionPreset;\n\n      if (headerTransitionPreset) {\n        if (HEADER_TRANSITION_PRESET.includes(headerTransitionPreset)) {\n          return headerTransitionPreset;\n        }\n\n        if (__DEV__) {\n          console.error(\"Invalid configuration applied for headerTransitionPreset - expected one of \" + HEADER_TRANSITION_PRESET.join(', ') + \" but received \" + JSON.stringify(headerTransitionPreset));\n        }\n      }\n\n      return 'fade-in-place';\n    }\n  }, {\n    key: \"getHeaderBackTitleVisible\",\n    value: function getHeaderBackTitleVisible() {\n      var headerBackTitleVisible = this.props.headerBackTitleVisible;\n      var layoutPreset = this.getHeaderLayoutPreset();\n      var enabledByDefault = !(layoutPreset === 'left' || _reactNative.Platform.OS !== 'ios');\n      return typeof headerBackTitleVisible === 'boolean' ? headerBackTitleVisible : enabledByDefault;\n    }\n  }, {\n    key: \"renderInnerScene\",\n    value: function renderInnerScene(scene) {\n      var _scene$descriptor = scene.descriptor,\n          navigation = _scene$descriptor.navigation,\n          getComponent = _scene$descriptor.getComponent;\n      var SceneComponent = getComponent();\n      var screenProps = this.props.screenProps;\n      var headerMode = this.getHeaderMode();\n\n      if (headerMode === 'screen') {\n        return React.createElement(_reactNative.View, {\n          style: styles.container,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 887\n          }\n        }, React.createElement(_reactNative.View, {\n          style: styles.scenes,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 888\n          }\n        }, React.createElement(_reactNavigation.SceneView, {\n          screenProps: screenProps,\n          navigation: navigation,\n          component: SceneComponent,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 889\n          }\n        })), this.renderHeader(scene, headerMode));\n      }\n\n      return React.createElement(_reactNavigation.SceneView, {\n        screenProps: screenProps,\n        navigation: navigation,\n        component: SceneComponent,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 900\n        }\n      });\n    }\n  }, {\n    key: \"prepareTransitionConfig\",\n    value: function prepareTransitionConfig() {\n      this.transitionConfig = _StackViewTransitionConfigs.default.getTransitionConfig(this.props.transitionConfig, (0, _objectSpread2.default)({}, this.props.transitionProps, {\n        position: this.position\n      }), this.props.lastTransitionProps, this.isModal());\n    }\n  }, {\n    key: \"preparePosition\",\n    value: function preparePosition() {\n      if (this.gesturePosition) {\n        this.position = _reactNative.Animated.add(_reactNative.Animated.multiply(this.props.transitionProps.position, this.positionSwitch), _reactNative.Animated.multiply(this.gesturePosition, this.gestureSwitch));\n      } else {\n        this.position = this.props.transitionProps.position;\n      }\n    }\n  }]);\n  return StackViewLayout;\n}(React.Component);\n\nStackViewLayout.contextType = _reactNavigation.ThemeContext;\n\nvar styles = _reactNative.StyleSheet.create({\n  container: {\n    flex: 1,\n    flexDirection: 'column-reverse',\n    overflow: 'hidden'\n  },\n  scenes: {\n    flex: 1\n  },\n  floatingHeader: {\n    position: _reactNative.Platform.select({\n      default: 'absolute',\n      web: 'fixed'\n    }),\n    left: 0,\n    top: 0,\n    right: 0\n  }\n});\n\nvar _default = (0, _reactNavigation.withOrientation)(StackViewLayout);\n\nexports.default = _default;","map":{"version":3,"sources":["StackViewLayout.tsx"],"names":["IPHONE_XS_HEIGHT","IPHONE_XR_HEIGHT","width","WINDOW_WIDTH","height","WINDOW_HEIGHT","Dimensions","IS_IPHONE_X","Platform","EaseInOut","Easing","HEADER_LAYOUT_PRESET","HEADER_TRANSITION_PRESET","HEADER_BACKGROUND_TRANSITION_PRESET","ANIMATION_DURATION","POSITION_THRESHOLD","GESTURE_RESPONSE_DISTANCE_HORIZONTAL","GESTURE_RESPONSE_DISTANCE_VERTICAL","USE_NATIVE_DRIVER","getDefaultHeaderHeight","isLandscape","StackViewLayout","React","Component","contextType","ThemeContext","immediateIndex","Animated","nativeEvent","translationX","translationY","useNativeDriver","floatingHeaderHeight","props","scene","headerMode","options","header","headerShown","__DEV__","renderHeader","headerLeftInterpolator","headerTitleInterpolator","headerRightInterpolator","headerBackgroundInterpolator","backgroundTransitionPresetInterpolator","transitionProps","passProps","position","mode","transitionPreset","layoutPreset","backTitleVisible","leftInterpolator","titleInterpolator","rightInterpolator","backgroundInterpolator","resetToIndex","duration","toValue","stiffness","damping","mass","overshootClamping","restDisplacementThreshold","restSpeedThreshold","easing","backFromIndex","navigation","scenes","Math","onCompleteAnimation","backFromScene","s","NavigationActions","key","immediate","StackActions","e","index","floatingHeader","styles","prevProps","prevState","state","userGestureResponseDistance","layout","gestureResponseDistance","isMotionInverted","maxDeltaX","minOffsetY","hitSlop","top","bottom","minOffsetX","maxDeltaY","left","right","gesturesEnabled","gestureDirection","I18nManager","distance","x","value","clamp","y","GestureState","inputRange","outputRange","extrapolate","movementDirection","movedDistance","gestureVelocity","defaultVelocity","velocity","resetDuration","goBackDuration","headerBackgroundTransitionPreset","HeaderStyleInterpolator","console","JSON","headerLayoutPreset","headerTransitionPreset","headerBackTitleVisible","enabledByDefault","getComponent","SceneComponent","screenProps","TransitionConfigs","cardShadowEnabled","cardOverlayEnabled","transparentCard","cardStyle","screenInterpolator","style","shadowEnabled","hasHeader","floatingContainerStyle","StyleSheet","web","default","paddingTop","container","flex","flexDirection","overflow","withOrientation"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  Animated,\n  StyleSheet,\n  Platform,\n  View,\n  I18nManager,\n  Easing,\n  Dimensions,\n  ViewStyle,\n  LayoutChangeEvent,\n} from 'react-native';\nimport {\n  SceneView,\n  StackActions,\n  NavigationActions,\n  NavigationProvider,\n  ThemeContext,\n  withOrientation,\n} from 'react-navigation';\nimport { ScreenContainer } from 'react-native-screens';\nimport {\n  PanGestureHandler,\n  State as GestureState,\n  PanGestureHandlerGestureEvent,\n  GestureHandlerGestureEventNativeEvent,\n  PanGestureHandlerEventExtra,\n} from 'react-native-gesture-handler';\n\nimport Card from './StackViewCard';\nimport Header from '../Header/Header';\nimport TransitionConfigs from './StackViewTransitionConfigs';\nimport HeaderStyleInterpolator from '../Header/HeaderStyleInterpolator';\nimport StackGestureContext from '../../utils/StackGestureContext';\nimport clamp from '../../utils/clamp';\nimport { supportsImprovedSpringAnimation } from '../../utils/ReactNativeFeatures';\nimport {\n  Scene,\n  HeaderMode,\n  TransitionProps,\n  TransitionConfig,\n  HeaderTransitionConfig,\n  HeaderProps,\n  NavigationStackConfig,\n} from '../../types';\n\ntype Props = NavigationStackConfig & {\n  isLandscape: boolean;\n  transitionProps: TransitionProps;\n  lastTransitionProps?: TransitionProps;\n  transitionConfig?: (\n    transitionProps: TransitionProps,\n    prevTransitionProps?: TransitionProps,\n    isModal?: boolean\n  ) => TransitionConfig;\n  onGestureBegin?: () => void;\n  onGestureEnd?: () => void;\n  onGestureCanceled?: () => void;\n  screenProps?: unknown;\n};\n\ntype State = {\n  floatingHeaderHeight: number;\n};\n\nconst IPHONE_XS_HEIGHT = 812; // iPhone X and XS\nconst IPHONE_XR_HEIGHT = 896; // iPhone XR and XS Max\nconst { width: WINDOW_WIDTH, height: WINDOW_HEIGHT } = Dimensions.get('window');\nconst IS_IPHONE_X =\n  Platform.OS === 'ios' &&\n  // @ts-ignore\n  !Platform.isPad &&\n  // @ts-ignore\n  !Platform.isTVOS &&\n  (WINDOW_HEIGHT === IPHONE_XS_HEIGHT ||\n    WINDOW_WIDTH === IPHONE_XS_HEIGHT ||\n    WINDOW_HEIGHT === IPHONE_XR_HEIGHT ||\n    WINDOW_WIDTH === IPHONE_XR_HEIGHT);\n\nconst EaseInOut = Easing.inOut(Easing.ease);\n\n/**\n * Enumerate possible values for validation\n */\nconst HEADER_LAYOUT_PRESET = ['center', 'left'];\nconst HEADER_TRANSITION_PRESET = ['fade-in-place', 'uikit'];\nconst HEADER_BACKGROUND_TRANSITION_PRESET = ['toggle', 'fade', 'translate'];\n\n/**\n * The max duration of the card animation in milliseconds after released gesture.\n * The actual duration should be always less then that because the rest distance\n * is always less then the full distance of the layout.\n */\nconst ANIMATION_DURATION = 500;\n\n/**\n * The gesture distance threshold to trigger the back behavior. For instance,\n * `1/2` means that moving greater than 1/2 of the width of the screen will\n * trigger a back action\n */\nconst POSITION_THRESHOLD = 1 / 2;\n\n/**\n * The distance of touch start from the edge of the screen where the gesture will be recognized\n */\nconst GESTURE_RESPONSE_DISTANCE_HORIZONTAL = 50;\nconst GESTURE_RESPONSE_DISTANCE_VERTICAL = 135;\n\nconst USE_NATIVE_DRIVER = Platform.OS === 'android' || Platform.OS === 'ios';\n\nconst getDefaultHeaderHeight = (isLandscape: boolean) => {\n  if (Platform.OS === 'ios') {\n    // @ts-ignore\n    if (isLandscape && !Platform.isPad) {\n      return 32;\n    } else if (IS_IPHONE_X) {\n      return 88;\n    } else {\n      return 64;\n    }\n  } else if (Platform.OS === 'android') {\n    return 56;\n  } else {\n    return 64;\n  }\n};\n\nclass StackViewLayout extends React.Component<Props, State> {\n  static contextType = ThemeContext;\n\n  context!: React.ContextType<typeof ThemeContext>;\n\n  private panGestureRef: React.RefObject<PanGestureHandler>;\n  private gestureX: Animated.Value;\n  private gestureY: Animated.Value;\n  private positionSwitch: Animated.Value;\n  private gestureSwitch: Animated.AnimatedInterpolation;\n  private gestureEvent: (...args: any[]) => void;\n  private gesturePosition: Animated.AnimatedInterpolation | undefined;\n\n  // @ts-ignore\n  private position: Animated.Value;\n\n  /**\n   * immediateIndex is used to represent the expected index that we will be on after a\n   * transition. To achieve a smooth animation when swiping back, the action to go back\n   * doesn't actually fire until the transition completes. The immediateIndex is used during\n   * the transition so that gestures can be handled correctly. This is a work-around for\n   * cases when the user quickly swipes back several times.\n   */\n  private immediateIndex: number | null = null;\n  private transitionConfig:\n    | HeaderTransitionConfig & TransitionConfig\n    | undefined;\n  private prevProps: Props | undefined;\n\n  constructor(props: Props) {\n    super(props);\n    this.panGestureRef = React.createRef();\n    this.gestureX = new Animated.Value(0);\n    this.gestureY = new Animated.Value(0);\n    this.positionSwitch = new Animated.Value(1);\n    if (Animated.subtract) {\n      this.gestureSwitch = Animated.subtract(1, this.positionSwitch);\n    } else {\n      this.gestureSwitch = Animated.add(\n        1,\n        Animated.multiply(-1, this.positionSwitch)\n      );\n    }\n    this.gestureEvent = Animated.event(\n      [\n        {\n          nativeEvent: {\n            translationX: this.gestureX,\n            translationY: this.gestureY,\n          },\n        },\n      ],\n      {\n        useNativeDriver: USE_NATIVE_DRIVER,\n      }\n    );\n\n    this.state = {\n      // Used when card's header is null and mode is float to make transition\n      // between screens with headers and those without headers smooth.\n      // This is not a great heuristic here. We don't know synchronously\n      // on mount what the header height is so we have just used the most\n      // common cases here.\n      floatingHeaderHeight: getDefaultHeaderHeight(props.isLandscape),\n    };\n  }\n\n  private renderHeader(scene: Scene, headerMode: HeaderMode) {\n    const { options } = scene.descriptor;\n    const { header, headerShown } = options;\n\n    if (__DEV__ && typeof header === 'string') {\n      throw new Error(\n        `Invalid header value: \"${header}\". The header option must be a valid React component or null, not a string.`\n      );\n    }\n\n    if ((header === null || headerShown === false) && headerMode === 'screen') {\n      return null;\n    }\n\n    // check if it's a react element\n    if (React.isValidElement(header)) {\n      return header;\n    }\n\n    // Handle the case where the header option is a function, and provide the default\n    const renderHeader =\n      // @ts-ignore TS warns about missing props, but they are in default props\n      header || ((props: HeaderProps) => <Header {...props} />);\n\n    let {\n      headerLeftInterpolator,\n      headerTitleInterpolator,\n      headerRightInterpolator,\n      headerBackgroundInterpolator,\n    } = this.transitionConfig as HeaderTransitionConfig;\n\n    const backgroundTransitionPresetInterpolator = this.getHeaderBackgroundTransitionPreset();\n    if (backgroundTransitionPresetInterpolator) {\n      headerBackgroundInterpolator = backgroundTransitionPresetInterpolator;\n    }\n\n    const { transitionProps, ...passProps } = this.props;\n\n    return (\n      <NavigationProvider value={scene.descriptor.navigation}>\n        {renderHeader({\n          ...passProps,\n          ...transitionProps,\n          position: this.position,\n          scene,\n          mode: headerMode,\n          transitionPreset: this.getHeaderTransitionPreset(),\n          layoutPreset: this.getHeaderLayoutPreset(),\n          backTitleVisible: this.getHeaderBackTitleVisible(),\n          leftInterpolator: headerLeftInterpolator,\n          titleInterpolator: headerTitleInterpolator,\n          rightInterpolator: headerRightInterpolator,\n          backgroundInterpolator: headerBackgroundInterpolator,\n        })}\n      </NavigationProvider>\n    );\n  }\n\n  private reset(resetToIndex: number, duration: number) {\n    if (Platform.OS === 'ios' && supportsImprovedSpringAnimation()) {\n      // @ts-ignore\n      Animated.spring(this.props.transitionProps.position, {\n        toValue: resetToIndex,\n        stiffness: 6000,\n        damping: 100,\n        mass: 3,\n        overshootClamping: true,\n        restDisplacementThreshold: 0.01,\n        restSpeedThreshold: 0.01,\n        useNativeDriver: USE_NATIVE_DRIVER,\n      }).start();\n    } else {\n      // @ts-ignore\n      Animated.timing(this.props.transitionProps.position, {\n        toValue: resetToIndex,\n        duration,\n        easing: EaseInOut,\n        useNativeDriver: USE_NATIVE_DRIVER,\n      }).start();\n    }\n  }\n\n  private goBack(backFromIndex: number, duration: number) {\n    const { navigation, position, scenes } = this.props.transitionProps;\n    const toValue = Math.max(backFromIndex - 1, 0);\n\n    // set temporary index for gesture handler to respect until the action is\n    // dispatched at the end of the transition.\n    this.immediateIndex = toValue;\n\n    const onCompleteAnimation = () => {\n      this.immediateIndex = null;\n      const backFromScene = scenes.find(s => s.index === toValue + 1);\n      if (backFromScene) {\n        navigation.dispatch(\n          NavigationActions.back({\n            key: backFromScene.route.key,\n            immediate: true,\n          })\n        );\n        navigation.dispatch(StackActions.completeTransition());\n      }\n    };\n\n    if (Platform.OS === 'ios' && supportsImprovedSpringAnimation()) {\n      // @ts-ignore\n      Animated.spring(position, {\n        toValue,\n        stiffness: 7000,\n        damping: 300,\n        mass: 3,\n        overshootClamping: true,\n        restDisplacementThreshold: 0.01,\n        restSpeedThreshold: 0.01,\n        useNativeDriver: USE_NATIVE_DRIVER,\n      }).start(onCompleteAnimation);\n    } else {\n      // @ts-ignore\n      Animated.timing(position, {\n        toValue,\n        duration,\n        easing: EaseInOut,\n        useNativeDriver: USE_NATIVE_DRIVER,\n      }).start(onCompleteAnimation);\n    }\n  }\n\n  private handleFloatingHeaderLayout = (e: LayoutChangeEvent) => {\n    const { height } = e.nativeEvent.layout;\n    if (height !== this.state.floatingHeaderHeight) {\n      this.setState({ floatingHeaderHeight: height });\n    }\n  };\n\n  private prepareAnimated() {\n    if (this.props === this.prevProps) {\n      return;\n    }\n    this.prevProps = this.props;\n\n    this.prepareGesture();\n    this.preparePosition();\n    this.prepareTransitionConfig();\n  }\n\n  render() {\n    this.prepareAnimated();\n\n    const { transitionProps } = this.props;\n    const {\n      navigation: {\n        state: { index },\n      },\n      scenes,\n    } = transitionProps;\n\n    const headerMode = this.getHeaderMode();\n    let floatingHeader = null;\n    if (headerMode === 'float') {\n      const { scene } = transitionProps;\n      floatingHeader = (\n        <View\n          style={styles.floatingHeader}\n          pointerEvents=\"box-none\"\n          onLayout={this.handleFloatingHeaderLayout}\n        >\n          {this.renderHeader(scene, headerMode)}\n        </View>\n      );\n    }\n\n    return (\n      <PanGestureHandler\n        {...this.gestureActivationCriteria()}\n        ref={this.panGestureRef}\n        onGestureEvent={this.gestureEvent}\n        onHandlerStateChange={this.handlePanGestureStateChange}\n        enabled={index > 0 && this.isGestureEnabled()}\n      >\n        <Animated.View\n          style={[\n            styles.container,\n            this.context === 'light'\n              ? this.transitionConfig!.containerStyleLight\n              : this.transitionConfig!.containerStyleDark,\n            this.transitionConfig!.containerStyle,\n          ]}\n        >\n          <StackGestureContext.Provider value={this.panGestureRef}>\n            <ScreenContainer style={styles.scenes}>\n              {scenes.map(this.renderCard)}\n            </ScreenContainer>\n            {floatingHeader}\n          </StackGestureContext.Provider>\n        </Animated.View>\n      </PanGestureHandler>\n    );\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    const { state: prevState } = prevProps.transitionProps.navigation;\n    const { state } = this.props.transitionProps.navigation;\n    if (prevState.index !== state.index) {\n      this.maybeCancelGesture();\n    }\n  }\n\n  private getGestureResponseDistance() {\n    const { scene } = this.props.transitionProps;\n    const { options } = scene.descriptor;\n    const {\n      gestureResponseDistance: userGestureResponseDistance = {} as {\n        vertical?: number;\n        horizontal?: number;\n      },\n    } = options;\n\n    // Doesn't make sense for a response distance of 0, so this works fine\n    return this.isModal()\n      ? userGestureResponseDistance.vertical ||\n          GESTURE_RESPONSE_DISTANCE_VERTICAL\n      : userGestureResponseDistance.horizontal ||\n          GESTURE_RESPONSE_DISTANCE_HORIZONTAL;\n  }\n\n  private gestureActivationCriteria() {\n    const { layout } = this.props.transitionProps;\n    const gestureResponseDistance = this.getGestureResponseDistance();\n    const isMotionInverted = this.isMotionInverted();\n\n    if (this.isMotionVertical()) {\n      // @ts-ignore\n      const height: number = layout.height.__getValue();\n\n      return {\n        maxDeltaX: 15,\n        minOffsetY: isMotionInverted ? -5 : 5,\n        hitSlop: isMotionInverted\n          ? { top: -height + gestureResponseDistance }\n          : { bottom: -height + gestureResponseDistance },\n      };\n    } else {\n      // @ts-ignore\n      const width: number = layout.width.__getValue();\n      const hitSlop = -width + gestureResponseDistance;\n\n      return {\n        minOffsetX: isMotionInverted ? -5 : 5,\n        maxDeltaY: 20,\n        hitSlop: isMotionInverted ? { left: hitSlop } : { right: hitSlop },\n      };\n    }\n  }\n\n  private isGestureEnabled() {\n    const gesturesEnabled = this.props.transitionProps.scene.descriptor.options\n      .gesturesEnabled;\n    return typeof gesturesEnabled === 'boolean'\n      ? gesturesEnabled\n      : Platform.OS === 'ios';\n  }\n\n  private isMotionVertical() {\n    return this.isModal();\n  }\n\n  private isModal() {\n    return this.props.mode === 'modal';\n  }\n\n  // This only currently applies to the horizontal gesture!\n  private isMotionInverted() {\n    const {\n      transitionProps: { scene },\n    } = this.props;\n    const { options } = scene.descriptor;\n    const { gestureDirection } = options;\n\n    if (this.isModal()) {\n      return gestureDirection === 'inverted';\n    } else {\n      return typeof gestureDirection === 'string'\n        ? gestureDirection === 'inverted'\n        : I18nManager.isRTL;\n    }\n  }\n\n  private computeHorizontalGestureValue({\n    translationX,\n  }: {\n    translationX: number;\n  }) {\n    const {\n      transitionProps: { navigation, layout },\n    } = this.props;\n\n    const { index } = navigation.state;\n\n    // TODO: remove this __getValue!\n    // @ts-ignore\n    const distance: number = layout.width.__getValue();\n\n    const x = this.isMotionInverted() ? -1 * translationX : translationX;\n\n    const value = index - x / distance;\n    return clamp(index - 1, value, index);\n  }\n\n  private computeVerticalGestureValue({\n    translationY,\n  }: {\n    translationY: number;\n  }) {\n    const {\n      transitionProps: { navigation, layout },\n    } = this.props;\n\n    const { index } = navigation.state;\n\n    // TODO: remove this __getValue!\n    // @ts-ignore\n    const distance: number = layout.height.__getValue();\n\n    const y = this.isMotionInverted() ? -1 * translationY : translationY;\n    const value = index - y / distance;\n    return clamp(index - 1, value, index);\n  }\n\n  private handlePanGestureStateChange = ({\n    nativeEvent,\n  }: PanGestureHandlerGestureEvent) => {\n    // @ts-ignore\n    if (nativeEvent.oldState === GestureState.ACTIVE) {\n      // Gesture was cancelled! For example, some navigation state update\n      // arrived while the gesture was active that cancelled it out\n      // @ts-ignore\n      if (this.positionSwitch.__getValue() === 1) {\n        return;\n      }\n\n      if (this.isMotionVertical()) {\n        this.handleReleaseVertical(nativeEvent);\n      } else {\n        this.handleReleaseHorizontal(nativeEvent);\n      }\n    } else if (nativeEvent.state === GestureState.ACTIVE) {\n      this.props.onGestureBegin && this.props.onGestureBegin();\n\n      // Switch to using gesture position\n      this.positionSwitch.setValue(0);\n\n      // By enabling the gesture switch and ignoring the position here we\n      // end up with a quick jump to the initial value and then back to the\n      // gesture. While this isn't ideal, it's preferred over preventing new\n      // gestures during the animation (all gestures should be interruptible)\n      // and we will properly fix it (interruptible and from the correct position)\n      // when we integrate reanimated. If you prefer to prevent gestures during\n      // transitions, then fork this library, comment the positionSwitch value set above,\n      // and uncomment the following two lines.\n      // if (!this.props.transitionProps.position._animation) {\n      //   this.positionSwitch.setValue(0);\n      // }\n    }\n  };\n\n  // note: this will not animated so nicely because the position is unaware\n  // of the gesturePosition, so if we are in the middle of swiping the screen away\n  // and back is programatically fired then we will reset to the initial position\n  // and animate from there\n  private maybeCancelGesture() {\n    this.positionSwitch.setValue(1);\n  }\n\n  private prepareGesture() {\n    if (!this.isGestureEnabled()) {\n      // @ts-ignore\n      if (this.positionSwitch.__getValue() !== 1) {\n        this.positionSwitch.setValue(1);\n      }\n      this.gesturePosition = undefined;\n      return;\n    }\n\n    // We can't run the gesture if width or height layout is unavailable\n    if (\n      // @ts-ignore\n      this.props.transitionProps.layout.width.__getValue() === 0 ||\n      // @ts-ignore\n      this.props.transitionProps.layout.height.__getValue() === 0\n    ) {\n      return;\n    }\n\n    if (this.isMotionVertical()) {\n      this.prepareGestureVertical();\n    } else {\n      this.prepareGestureHorizontal();\n    }\n  }\n\n  private prepareGestureHorizontal() {\n    const { index } = this.props.transitionProps.navigation.state;\n\n    if (this.isMotionInverted()) {\n      this.gesturePosition = Animated.add(\n        index,\n        Animated.divide(this.gestureX, this.props.transitionProps.layout.width)\n      ).interpolate({\n        inputRange: [index - 1, index],\n        outputRange: [index - 1, index],\n        extrapolate: 'clamp',\n      });\n    } else {\n      this.gesturePosition = Animated.add(\n        index,\n        Animated.multiply(\n          -1,\n          Animated.divide(\n            this.gestureX,\n            this.props.transitionProps.layout.width\n          )\n        )\n      ).interpolate({\n        inputRange: [index - 1, index],\n        outputRange: [index - 1, index],\n        extrapolate: 'clamp',\n      });\n    }\n  }\n\n  private prepareGestureVertical() {\n    const { index } = this.props.transitionProps.navigation.state;\n\n    if (this.isMotionInverted()) {\n      this.gesturePosition = Animated.add(\n        index,\n        Animated.divide(this.gestureY, this.props.transitionProps.layout.height)\n      ).interpolate({\n        inputRange: [index - 1, index],\n        outputRange: [index - 1, index],\n        extrapolate: 'clamp',\n      });\n    } else {\n      this.gesturePosition = Animated.add(\n        index,\n        Animated.multiply(\n          -1,\n          Animated.divide(\n            this.gestureY,\n            this.props.transitionProps.layout.height\n          )\n        )\n      ).interpolate({\n        inputRange: [index - 1, index],\n        outputRange: [index - 1, index],\n        extrapolate: 'clamp',\n      });\n    }\n  }\n\n  private handleReleaseHorizontal(\n    nativeEvent: GestureHandlerGestureEventNativeEvent &\n      PanGestureHandlerEventExtra\n  ) {\n    const {\n      transitionProps: { navigation, position, layout },\n    } = this.props;\n    const { index } = navigation.state;\n    const immediateIndex =\n      this.immediateIndex == null ? index : this.immediateIndex;\n\n    // Calculate animate duration according to gesture speed and moved distance\n    // @ts-ignore\n    const distance = layout.width.__getValue();\n    const movementDirection = this.isMotionInverted() ? -1 : 1;\n    const movedDistance = movementDirection * nativeEvent.translationX;\n    const gestureVelocity = movementDirection * nativeEvent.velocityX;\n    const defaultVelocity = distance / ANIMATION_DURATION;\n    const velocity = Math.max(Math.abs(gestureVelocity), defaultVelocity);\n    const resetDuration = this.isMotionInverted()\n      ? (distance - movedDistance) / velocity\n      : movedDistance / velocity;\n    const goBackDuration = this.isMotionInverted()\n      ? movedDistance / velocity\n      : (distance - movedDistance) / velocity;\n\n    // Get the current position value and reset to using the statically driven\n    // (rather than gesture driven) position.\n    const value = this.computeHorizontalGestureValue(nativeEvent);\n    position.setValue(value);\n    this.positionSwitch.setValue(1);\n\n    // If the speed of the gesture release is significant, use that as the indication\n    // of intent\n    if (gestureVelocity < -50) {\n      this.props.onGestureCanceled && this.props.onGestureCanceled();\n      this.reset(immediateIndex, resetDuration);\n      return;\n    }\n    if (gestureVelocity > 50) {\n      this.props.onGestureEnd && this.props.onGestureEnd();\n      this.goBack(immediateIndex, goBackDuration);\n      return;\n    }\n\n    // Then filter based on the distance the screen was moved. Over a third of the way swiped,\n    // and the back will happen.\n    if (value <= index - POSITION_THRESHOLD) {\n      this.props.onGestureEnd && this.props.onGestureEnd();\n      this.goBack(immediateIndex, goBackDuration);\n    } else {\n      this.props.onGestureCanceled && this.props.onGestureCanceled();\n      this.reset(immediateIndex, resetDuration);\n    }\n  }\n\n  private handleReleaseVertical(\n    nativeEvent: GestureHandlerGestureEventNativeEvent &\n      PanGestureHandlerEventExtra\n  ) {\n    const {\n      transitionProps: { navigation, position, layout },\n    } = this.props;\n    const { index } = navigation.state;\n    const immediateIndex =\n      this.immediateIndex == null ? index : this.immediateIndex;\n\n    // Calculate animate duration according to gesture speed and moved distance\n    // @ts-ignore\n    const distance = layout.height.__getValue();\n    const isMotionInverted = this.isMotionInverted();\n    const movementDirection = isMotionInverted ? -1 : 1;\n    const movedDistance = movementDirection * nativeEvent.translationY;\n    const gestureVelocity = movementDirection * nativeEvent.velocityY;\n    const defaultVelocity = distance / ANIMATION_DURATION;\n    const velocity = Math.max(Math.abs(gestureVelocity), defaultVelocity);\n    const resetDuration = isMotionInverted\n      ? (distance - movedDistance) / velocity\n      : movedDistance / velocity;\n    const goBackDuration = isMotionInverted\n      ? movedDistance / velocity\n      : (distance - movedDistance) / velocity;\n\n    const value = this.computeVerticalGestureValue(nativeEvent);\n    position.setValue(value);\n    this.positionSwitch.setValue(1);\n\n    // If the speed of the gesture release is significant, use that as the indication\n    // of intent\n    if (gestureVelocity < -50) {\n      this.props.onGestureCanceled && this.props.onGestureCanceled();\n      this.reset(immediateIndex, resetDuration);\n      return;\n    }\n    if (gestureVelocity > 50) {\n      this.props.onGestureEnd && this.props.onGestureEnd();\n      this.goBack(immediateIndex, goBackDuration);\n      return;\n    }\n\n    // Then filter based on the distance the screen was moved. Over a third of the way swiped,\n    // and the back will happen.\n    if (value <= index - POSITION_THRESHOLD) {\n      this.props.onGestureEnd && this.props.onGestureEnd();\n      this.goBack(immediateIndex, goBackDuration);\n    } else {\n      this.props.onGestureCanceled && this.props.onGestureCanceled();\n      this.reset(immediateIndex, resetDuration);\n    }\n  }\n\n  private getHeaderMode() {\n    if (this.props.headerMode) {\n      return this.props.headerMode;\n    }\n    if (Platform.OS === 'android' || this.props.mode === 'modal') {\n      return 'screen';\n    }\n    // On web, the float header mode will enable body scrolling and stick the header\n    // to the top of the URL bar when it shrinks and expands.\n    return 'float';\n  }\n\n  private getHeaderBackgroundTransitionPreset() {\n    const { headerBackgroundTransitionPreset } = this.props;\n    if (headerBackgroundTransitionPreset) {\n      if (\n        HEADER_BACKGROUND_TRANSITION_PRESET.includes(\n          headerBackgroundTransitionPreset\n        )\n      ) {\n        if (headerBackgroundTransitionPreset === 'fade') {\n          return HeaderStyleInterpolator.forBackgroundWithFade;\n        } else if (headerBackgroundTransitionPreset === 'translate') {\n          return HeaderStyleInterpolator.forBackgroundWithTranslation;\n        } else if (headerBackgroundTransitionPreset === 'toggle') {\n          return HeaderStyleInterpolator.forBackgroundWithInactiveHidden;\n        }\n      } else if (__DEV__) {\n        console.error(\n          `Invalid configuration applied for headerBackgroundTransitionPreset - expected one of ${HEADER_BACKGROUND_TRANSITION_PRESET.join(\n            ', '\n          )} but received ${JSON.stringify(headerBackgroundTransitionPreset)}`\n        );\n      }\n    }\n\n    return null;\n  }\n\n  private getHeaderLayoutPreset() {\n    const { headerLayoutPreset } = this.props;\n    if (headerLayoutPreset) {\n      if (__DEV__) {\n        if (\n          this.getHeaderTransitionPreset() === 'uikit' &&\n          headerLayoutPreset === 'left' &&\n          Platform.OS === 'ios'\n        ) {\n          console.warn(\n            `headerTransitionPreset with the value 'uikit' is incompatible with headerLayoutPreset 'left'`\n          );\n        }\n      }\n      if (HEADER_LAYOUT_PRESET.includes(headerLayoutPreset)) {\n        return headerLayoutPreset;\n      }\n\n      if (__DEV__) {\n        console.error(\n          `Invalid configuration applied for headerLayoutPreset - expected one of ${HEADER_LAYOUT_PRESET.join(\n            ', '\n          )} but received ${JSON.stringify(headerLayoutPreset)}`\n        );\n      }\n    }\n\n    if (Platform.OS !== 'ios') {\n      return 'left';\n    } else {\n      return 'center';\n    }\n  }\n\n  private getHeaderTransitionPreset() {\n    // On Android or with header mode screen, we always just use in-place,\n    // we ignore the option entirely (at least until we have other presets)\n    if (Platform.OS !== 'ios' || this.getHeaderMode() === 'screen') {\n      return 'fade-in-place';\n    }\n\n    const { headerTransitionPreset } = this.props;\n    if (headerTransitionPreset) {\n      if (HEADER_TRANSITION_PRESET.includes(headerTransitionPreset)) {\n        return headerTransitionPreset;\n      }\n\n      if (__DEV__) {\n        console.error(\n          `Invalid configuration applied for headerTransitionPreset - expected one of ${HEADER_TRANSITION_PRESET.join(\n            ', '\n          )} but received ${JSON.stringify(headerTransitionPreset)}`\n        );\n      }\n    }\n\n    return 'fade-in-place';\n  }\n\n  private getHeaderBackTitleVisible() {\n    const { headerBackTitleVisible } = this.props;\n    const layoutPreset = this.getHeaderLayoutPreset();\n\n    // Even when we align to center on Android, people should need to opt-in to\n    // showing the back title\n    const enabledByDefault = !(\n      layoutPreset === 'left' || Platform.OS !== 'ios'\n    );\n\n    return typeof headerBackTitleVisible === 'boolean'\n      ? headerBackTitleVisible\n      : enabledByDefault;\n  }\n\n  private renderInnerScene(scene: Scene) {\n    const { navigation, getComponent } = scene.descriptor;\n    const SceneComponent = getComponent();\n\n    const { screenProps } = this.props;\n    const headerMode = this.getHeaderMode();\n    if (headerMode === 'screen') {\n      return (\n        <View style={styles.container}>\n          <View style={styles.scenes}>\n            <SceneView\n              screenProps={screenProps}\n              navigation={navigation}\n              component={SceneComponent}\n            />\n          </View>\n          {this.renderHeader(scene, headerMode)}\n        </View>\n      );\n    }\n    return (\n      <SceneView\n        screenProps={screenProps}\n        navigation={navigation}\n        component={SceneComponent}\n      />\n    );\n  }\n\n  private prepareTransitionConfig() {\n    this.transitionConfig = TransitionConfigs.getTransitionConfig(\n      this.props.transitionConfig,\n      {\n        ...this.props.transitionProps,\n        position: this.position,\n      },\n      this.props.lastTransitionProps,\n      this.isModal()\n    );\n  }\n\n  private preparePosition() {\n    if (this.gesturePosition) {\n      // FIXME: this doesn't seem right, there is setValue called in some places\n      // @ts-ignore\n      this.position = Animated.add(\n        Animated.multiply(\n          this.props.transitionProps.position,\n          this.positionSwitch\n        ),\n        Animated.multiply(this.gesturePosition, this.gestureSwitch)\n      );\n    } else {\n      this.position = this.props.transitionProps.position;\n    }\n  }\n\n  private renderCard = (scene: Scene) => {\n    const {\n      transitionProps,\n      cardShadowEnabled,\n      cardOverlayEnabled,\n      transparentCard,\n      cardStyle,\n    } = this.props;\n\n    const { screenInterpolator } = this.transitionConfig as TransitionConfig;\n    const style =\n      screenInterpolator &&\n      screenInterpolator({\n        ...transitionProps,\n        shadowEnabled: cardShadowEnabled,\n        cardOverlayEnabled,\n        position: this.position,\n        scene,\n      });\n\n    // When using a floating header, we need to add some top\n    // padding on the scene.\n    const { options } = scene.descriptor;\n    const hasHeader = options.header !== null && options.headerShown !== false;\n    const headerMode = this.getHeaderMode();\n\n    let floatingContainerStyle: ViewStyle = StyleSheet.absoluteFill as ViewStyle;\n\n    if (hasHeader && headerMode === 'float' && !options.headerTransparent) {\n      floatingContainerStyle = {\n        ...Platform.select({\n          web: {} as ViewStyle,\n          default: StyleSheet.absoluteFillObject,\n        }),\n        paddingTop: this.state.floatingHeaderHeight,\n      };\n    }\n\n    return (\n      <Card\n        {...transitionProps}\n        key={`card_${scene.key}`}\n        position={this.position}\n        realPosition={transitionProps.position}\n        animatedStyle={style}\n        transparent={transparentCard}\n        style={[floatingContainerStyle, cardStyle]}\n        scene={scene}\n      >\n        {this.renderInnerScene(scene)}\n      </Card>\n    );\n  };\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    // Header is physically rendered after scenes so that Header won't be\n    // covered by the shadows of the scenes.\n    // That said, we'd have use `flexDirection: 'column-reverse'` to move\n    // Header above the scenes.\n    flexDirection: 'column-reverse',\n    overflow: 'hidden',\n  },\n  scenes: {\n    flex: 1,\n  },\n  floatingHeader: {\n    // @ts-ignore\n    position: Platform.select({ default: 'absolute', web: 'fixed' }),\n    left: 0,\n    top: 0,\n    right: 0,\n  },\n});\n\nexport default withOrientation(StackViewLayout);\n"]},"metadata":{},"sourceType":"script"}